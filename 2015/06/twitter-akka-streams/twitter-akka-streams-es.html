<div style="width:100%;float:left;">
    <img style="width:24%; float:left; padding: 0 1% 0 0" src="http://akka.io/resources/images/akka_full_color.svg"> </img>
    <p style="float:left; width:74%;">
        Reactive Streams  es una iniciativa para generar un  standard para procesamiento as&iacute;ncrono
        de flujos de datos,
        <a href="http://akka.io/"> El equpo de akka toolkit  </a> esta trabajando en una implementaci&oacute;n
        de este standard. Al momento de publicaci&oacute;n de este post (Junio 2015) el api es 
        a&uacute;n experimental pero funciona correctamente. 
        Este post  habla sobre como extraer informaci&oacute;n desde <a href="https:twitter.com"> twitter </a> 
         usando scala, akka toolkit y reactive streams.
    </p>
</div>

<h2> Interactuando con Tiwtter  </h2>

<p>
    No hay un cliente oficial de Twitter para scala sin embargo podemos usar
 <a href="http://twitter4j.org/en/index.html"> Twitter4j </a>  que tampoco es oficial pero funciona bien y es
    f&aacute;ciel de usar, a continuaci&oacute;n,  un ejemplo de como usar <a href="http://twitter4j.org/en/index.html"> Twitter4j </a>  en scala:
</p>

<pre>
    import twitter4j.TwitterFactory
    import twitter4j.Twitter
    import twitter4j.conf.ConfigurationBuilder

    ...
    ...

    val cb = new ConfigurationBuilder()
    cb.setDebugEnabled(true)
      .setOAuthConsumerKey("YOUR KEY HERE")
      .setOAuthConsumerSecret("YOUR SECRET HERE")
      .setOAuthAccessToken("YOUR ACCESS TOKEN")
      .setOAuthAccessTokenSecret("YOUR ACCESS TOKEN SECRET")
    val tf = new TwitterFactory(cb.build())
    val twitter = tf.getInstance()
 
</pre>

<p>
 Vamos a crear una aplicaci&oacute;n de l&iacute;nea de comandos que buscara tweets y los indexara por 
 contenido, usuarios y hashtags.
</p>

<h2> Akka streams </h2>

<p>
    Al momento de publicaci&oacute;n de este post (Junio 2015), akka streams es experimental, para importarlo
    correctamente en nuestro proyecto debemos agregar las siguientes l&iacute;neas a nuestro archivo de 
    configuraci&oacute;n sbt:
</p>

<pre>
    "com.typesafe.akka" % "akka-stream-experimental_2.11" % "1.0-RC3"
</pre>


<h3> Conceptos b&aacute;sicos </h3>

<p>
   A continuaci&oacute;n algunos conceptos b&aacute;sicos muy importantes extraidos de 
    <a href="http://doc.akka.io/docs/akka-stream-and-http-experimental">
    experimental akka stream documentation </a>  que son muy importantes de entender para construir
    aplicaciones reactivas:
</p>

<ul>
    <li>
        Source: Etapa de procesamiento con exactamente una entrada.
    </li>
    <li>
        Sink: Etapa de procesamiento con exactamente una salida.
    </li>
    <li>
        Flow: Etapa de procesamiento con una entrada y una salida.
    </li>

</ul>

<h3>  Construyendo y ejecutando un flujo a trav&eacute;s de un String </h3>


<p>
    Para poder ejecutar un Flujo(Stream) necesitamos al menos un Source o fuente de entrada
    y un Sink o desague de salida. En el siguiente ejemplo creamos una Fuente desde un iterador de Strings.
    Luego manipulamos cada l&iacute;nea para remover espacios, transformar el texto, etc.
    Una fuente por si sola no puede hacer nada, debe encadenarse a un Fluju(Flow) o a un desague (Sink),
    en el suguiente ejemplo usamos la funci&oacute;n  <code> runForeach </code> para transferir el Source
    a un Sink:
</p>

<pre>
    implicit val system = ActorSystem("Sys")
    import system.dispatcher

    implicit val materializer = ActorFlowMaterializer()

    val text =
      """I saw the best minds of my generation destroyed by madness,
      starving hysterical naked,
      dragging themselves through the negro streets at dawn looking for an angry fix,
      angel headed hipsters burning for the ancient heavenly connection to the starry dynamo in the machinery of night"""

    //build a source from an iterator
    Source(() => text.split(",").iterator)
      //transform every line
      .map(s => s.trim())
      .map(_.toUpperCase)
      //send every line to a sink
      .runForeach(s => println( s + "\n") )
      //shutdown when finish
      .onComplete(_ => system.shutdown())
</pre>

<h3> Construyendo un grafo sencillo </h3>

<p>
    Grafos son necesarios cuando se desee realizar una operacion   fan-in ("varias entradas") o fan-out
 ("varias salidas"). En el ejemplo a continuaci&oacute;n  usaremos la Source inicial 
 y la enviaremos a dos sitios simultaneamente: a la consola de comandos y a una archivo de texto:
</p>


<pre>
    implicit val system = ActorSystem("Sys")
    import system.dispatcher

    implicit val materializer = ActorFlowMaterializer()

    val text =
      """I saw the best minds of my generation destroyed by madness,
      starving hysterical naked,
      dragging themselves through the negro streets at dawn looking for an angry fix,
      angel headed hipsters burning for the ancient heavenly connection to the starry dynamo in the machinery of night"""



    // take a ByteString as input and write to disk
    val fileSink = SynchronousFileSink(new File("/tmp/outscala.txt"), true)

    // take a String as input and print it to the console
    val consoleSink = Sink.foreach(println)

    //takes a string and convert it to ByteString
    val flowConverter = Flow[String].map(s => ByteString.fromString(s))

    val g = FlowGraph.closed(fileSink, consoleSink)((_,cons) => cons) { implicit builder =>

      (f, console) =>
      import FlowGraph.Implicits._

      //build a source from an iterator
      val in = Source(List(text))
        //transform every line
        .map(s => s.trim())
        .map(_.toUpperCase)


      //Broadcast that take 1 entry and send it to 2 outputs
      val bcast = builder.add(Broadcast[String](2))

      in ~> bcast
            bcast ~> flowConverter ~> f
            bcast ~> console
    }.run()

    g.onComplete {
      case Success(_) =>
        system.shutdown()
      case Failure(e) =>
        println(s"Failure: ${e.getMessage}")
        system.shutdown()
    }
</pre>


<h2> Tweets Reactivos </h2>


<p>
    Nuestro objetivo es construir una aplicaci&oacute;n basada en akka toolkit que usara
    reactive streams para extraer tweets de twitter, clasificandolos por contenido y autor. Para hacer esto
    crearemos 3 &iacute;ndidices: tweets, authors, hashtags, a continuaci&oacute;n un diagrama
    simplificado de nuestra soluci&oacute;n:
</p>


<pre>


                                             +----------+
                                    +------- | Authors  |
                                    |        +----------+
                                    |
                                    |
                               +---------+
    +----------------+         | Tweets  |
    | Twitter Source |---------+---------+
    +----------------+              |
                                    |    +-----------+
                                    +----| Hashtags  |
                                         +-----------+
</pre>


<h3> Configurando el cliente </h3>


<p>
    Extramos credenciales de acceso de variables de entorno:
</p>

<pre>
  def getClient(): Twitter = {
    val api_key = sys.env("REACTIVE_TWITTER_API_KEY")
    val api_secret = sys.env("REACTIVE_TWITTER_API_SECRET")
    val access_token = sys.env("REACTIVE_TWITTER_ACCESS_TOKEN")
    val access_token_secret = sys.env("REACTIVE_TWITTER_ACCESS_TOKEN_SECRET")
    val cb = new ConfigurationBuilder()
    cb.setDebugEnabled(true)
      .setOAuthConsumerKey(api_key)
      .setOAuthConsumerSecret(api_secret)
      .setOAuthAccessToken(access_token)
      .setOAuthAccessTokenSecret(access_token_secret)
    val tf = new TwitterFactory(cb.build())
    tf.getInstance()
  }

</pre>


<h3> Construyendo la fuente </h3>

<pre>
    val client = getClient()
    val query = new Query(term);
    val tweets = Source( () => client.search(query).getTweets.asScala.iterator)
</pre>


<h3> Construyendo el grafo </h3>

<pre>
    val tweetPath = Paths.get(dataDir, "tweets.txt")
    val tweetSink = SynchronousFileSink(new File(tweetPath.toString), true)
    val authorPath = Paths.get(dataDir, "authors.txt")
    val authorSink = SynchronousFileSink(new File(authorPath.toString), true)
    val hashtagPath = Paths.get(dataDir, "hashtags.txt")
    val hashtagSink = SynchronousFileSink(new File(hashtagPath.toString), true)

    val tweetFlow = Flow[Status]

    val twitterGraph = FlowGraph.closed(tweets, tweetSink)( (tweets, tSink) => tSink) { implicit builder =>
      (in, tSink) =>
      import FlowGraph.Implicits._

    val DELIMITER = "==="

      //Broadcast that take 1 entry and send it to 2 outputs
      val bcast = builder.add(Broadcast[Status](3))

      in ~> bcast
            //bcast ~> tweetToStrFlow ~> autSink
            bcast ~> tweetFlow
              .map(t => ByteString.fromString(
                t.getId + DELIMITER  + t.getText + DELIMITER + t.getSource + "\n")) ~> tSink

            bcast ~> tweetFlow
            .map(t => ByteString.fromString(
              t.getId + DELIMITER + t.getUser.getId + DELIMITER
              + DELIMITER + t.getUser.getScreenName + DELIMITER + t.getUser.getName + "\n")) ~> authorSink

            bcast ~> tweetFlow
              .filter(t => t.getHashtagEntities.length > 0 )
              .map(t => {
                var lineList = ArrayBuffer.empty[String]
                lineList.append(t.getId + DELIMITER)
                t.getHashtagEntities.foreach(h => lineList.append(h.getText + DELIMITER))
                lineList.append("\n")
                ByteString.fromString(lineList.mkString(""))
              }) ~> hashtagSink
    }.run(
</pre>


<h2> Ejecutando el c&oacute;digo </h2>

<p>
    Primero debemos definir nuestras credenciales como variables de entorno:
</p>

<pre>
    export REACTIVE_TWITTER_API_KEY=API_KEY
    export REACTIVE_TWITTER_API_SECRET=API_SECRET
    export REACTIVE_TWITTER_ACCESS_TOKEN=ACCESS_TOKEN
    export REACTIVE_TWITTER_ACCESS_TOKEN_SECRET=TOKEN_SECRET
</pre>


<p>
    Luego podemos ejecutar <code> sbt </code>:
</p>

<pre>
    sbt clean "run --dataDir /tmp --query internet&colombia"
</pre>

<p>
    El c&oacute;digo fuente de este ejeemplo puede ser encontrado en el siguiente <a href="https://github.com/maigfrga/blog/tree/master/2015/06/twitter-akka-streams"> enlace </a>
</p>


<h2> Referencias </h2>

<ul>
    <li>
       <a href="http://www.typesafe.com/activator/template/akka-stream-scala"> Akka Streams with Scala </a>
    </li>
    <li>
       <a href="http://www.slideshare.net/ktoso/reactive-streams-akka-streams-geecon-prague-2014"> Reactive Streams / Akka Streams - GeeCON Prague 2014 </a>
    </li>
    <li>
        <a href="http://www.reactive-streams.org/">Reactive Streams</a>
    </li>
    <li>
        <a href="http://www.reactivemanifesto.org/">The reactive manifesto </a>
    </li>
    <li>
        <a href="http://alvinalexander.com/scala/scala-twitter-client-twitter-api-example"> A Scala Twitter client example</a>
    </li>
</ul>
