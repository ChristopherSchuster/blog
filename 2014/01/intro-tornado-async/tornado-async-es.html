Programaci&oacute;n as&iacute;ncrona con python y Tornado Framework
<p>
    Para poder entender como funciona la programaci&oacute;n as&iacute;ncrona es
    importante saber como funciona la programaci&on convencional y porque es un
    probela en aplicaciones web de alto trafico.
</p>


<h3>Una sencilla aplicaci&oacute;n de ejemplo:</h3>


<p>
    Imaginemos una aplicaci&oacute;n construida con un framework popular
    (django, flask, ruby on rails, java servlets, etc).

    Esta aplicaci&oacute;n funciona como un servidor directamente o detras de otro
    servidor como apache o nginx.

    Nuestra aplicaci&oacute; debe ejecutar los siguientes 4 pasos cada
    que un usuario hace una petici&oacute;n:
</p>

<ol>
    <li> Crear usuario in base de datos.</li>

    <li> Enviar email de confirmaci&oacute; a usuario.</li>

    <li> Compartir perfil social en redes sociales llamando apis externas.</li>

    <li>Enviar respuesta al usuario</li>

</ol>


<h3>Ejemplo S&iacute;ncrono</h3>

<p>
Cada vez que un usuario hace una petici&oacute;n a el programa empieza
a ejecutar de forma secuencial las instrucciones, asi que si el proceso de 
conectar a la base de datos para crear el registro y esperar el resultado 
demora 20 ms, el hilo principal no puede hacer nada m&acute;s mientras espera
la respuesta del servidor de BD. Esto quiere decir que el hilo esta
BLOQUEADO.
</p>

<p>
Luego de obtener la respuesta del servidor de Base de Datos el hilo principal
sigue su ejecuci&oacute;n, es tiempo ahora de enviar el email. Establecer la
conexi&oacute;n al servidor de correo, enviar el email y esperar la respuesta
toma 60 ms en los que el hilo esta de nuevo bloqueado. De igual forma al 
enviar la informaci&oacute;n al API social estar&aacute; el hilo bloqueado
200 ms. 
En total el hilo esta inactivo y BLOQUEADO = 20ms + 60ms + 200ms =
280ms
</p>

<p>El siguiente diagrama muestra el flujo de esta soluci&oacute;n</p>

<img src="https://raw.github.com/maigfrga/blog/master/2014/01/intro-tornado-async/sync_example.png" class="img-polaroid">



<h4>Ejemplo</h4>

<h5> Modelo</h5>

<p>Una simple clase que emula el delay:</p>


<pre>
    import time


    class User(object):
        def save(self):
            time.delay(0.2)

        def send_email(self):
            time.delay(0.6)

        def social_api(self):
            time.delay(2)

</pre>


<h5>El Servidor</h5>

<p>
In simple servidor Http construido con la libreria standar de python
http://docs.python.org/3/library/http.server.html, cualquier framework
web convencional  (django, flask, bottle, pylons, etc)  funciona de forma
similar: </p>

<pre>
    from models import User


    from datetime import datetime

    import http.server
    import socketserver

    class SyncServer(http.server.BaseHTTPRequestHandler):
        def do_GET(self, *args, **kwargs):
            user = User()
            user.save()
            user.send_email()
            user.social_api()
            self.send_response(200, message='ok')
            self.end_headers()

    def run():
        PORT = 8000

        Handler = SyncServer

        httpd = socketserver.TCPServer(("", PORT), Handler)

        print("serving at port", PORT)
        httpd.serve_forever()


    if __name__ == '__main__':
        run()

</pre>




<h3>Ejemplo As&iacute;ncrono</h3>

<p>
Cada vez que una petici&oacute;n es recibida, el hilo principal NO ejecuta
las tareas necesarias, en su lugar aplaza la ejecuci&oacute;n del codigo
para otro momento. 

Para mi ha sido dif&iacute;cil entender este concepto, voy a tratar de 
explicarlo con mis propias palabras que pueden no ser exactamente fieles a la
definici&oacute;n t&eacute;nica:

El hilo principal no ejecuta las tareas requeridas para realizar el trabajo, en su lugar el hilo hace un listado de las tareas requeridas y pasa este 
listado a otro componenete que es el responsable de ejecutar estas tareas, liberando el hilo princpal y evitando un bloqueo de este que no tiene nada por que esperar. El hilo princpial sigue procesando peticones mientras que el
otro componente ejecuta las tareas requeridas, una vez finaliza, devuelve el
control al hilo principal a traves de una llamada callback

La gran difirencia en el c&oacute;digo  as&iacute;ncrono es que el hilo 
princpial no se bloquea esperando el resultado de los servidores de base
de datos, smtp y el API social, por lo que puede usar este tiempo para
procesar nuevas peticiones.

Esto puede marcar una real diferencia de performace en aplicaciones web de
alto trafico.

Es importante destacar que esto no es magia negra, en ambos ejemplos, algun
componente estara bloqueado 280ms entre acceso a base de datos, servidor de
correo y API social.

El mayor reto cuando se escribe c&oacute;digo as&iacute;ncrono es cambiar
nuestro modelo mental y entender que el c&oacute;digo no se ejecuta 
inmediatamente, en su lugar la ejecuci&oacute;n es aplazada a un momento 
posterior donde el responsable de la tarea es otro componente diferente del 
hilo principal.


</p>
<p>La siguiente imagen muestra el flujo de este ejemplo</p>

<img src="https://raw.github.com/maigfrga/blog/master/2014/01/intro-tornado-async/async_example.png" class="img-polaroid">


<h4>Modulo Futures python </h4>

<p>
El modulo concurrent.futures tiene una interfaz de alto nivel para ejecutar
codigo as&iacute;ncrono, este patr&oacute;n fue introducido en python 3.2 y
disponible para versiones inferiores via pip. La documentaci&oacute;n 
oficial puede encontrarse en este enlace: 
http://docs.python.org/3.4/library/concurrent.futures.html
</p>

<h4>Ejemplo de c&oacute;digo usando Tornado Framework</h4>

<h5>The Model </h5>

<p>
Usamos la librer&iacute;a future de tornado http://www.tornadoweb.org/en/stable/concurrent.html para hacer nuestro c&oacute;digo as&iacute;ncrono: </p>

<pre>
    import time
    import datetime
    from tornado.concurrent import return_future

    class AsyncUser(object):
        @return_future
        def save(self, callback=None):
            time.sleep(0.02)
            result = datetime.datetime.utcnow()
            callback(result)

        @return_future
        def send_email(self, callback=None):
            time.sleep(0.06)
            result = datetime.datetime.utcnow()
            callback(result)

        @return_future
        def social_api(self, callback=None):
            time.sleep(0.2)
            result = datetime.datetime.utcnow()
            callback(result)

</pre>

<p>
El decorador @return_future convierte la funci&oacute;n decorada en 
as&iacute;ncrona, es importante llamar a la funci&oacute;n callback como 
ultima l&iacute;nea de la funci&oacute;n de esta forma se retornara un objeto
de tipo Future.

</p>

<h5>El servidor </h5>

<p>

tornado.gen  es una interfaz que retorna generadores y hace m&acute;s facil
trabajar con codigo as&iacute;ncrono. La documentaci&oacute;n completa
puede encontrarse en este enlace:
<a href="http://www.tornadoweb.org/en/stable/gen.html">http://www.tornadoweb.org/en/stable/gen.html </a>
</p>

<pre>

    import tornado.httpserver
    import tornado.ioloop
    import tornado.options
    import tornado.web

    from tornado import gen

    from models import AsyncUser

    class Application(tornado.web.Application):
        def __init__(self):
            handlers = [
                (r"/", UserHandler),
            ]
            tornado.web.Application.__init__(self, handlers)


    class UserHandler(tornado.web.RequestHandler):

        @gen.coroutine
        def get(self):
            user = AsyncUser()
            response = yield (user.save())

            response2 = yield (user.send_email())
            response3 = yield (user.social_api())
            self.finish()

    def main():
        http_server = tornado.httpserver.HTTPServer(Application())
        PORT = 8001
        print("serving at port", PORT)
        http_server.listen(PORT)
        tornado.ioloop.IOLoop.instance().start()


    if __name__ == "__main__":
        main()



</pre>

<h3>
    Comparaci&oacute;n Apache Benchmark
</h3>

<h4>
Servidor S&iacute;ncrono
</h4>

<pre>
    $ ab -c 12 -n 120  127.0.0.1:8000/

    Server Software:        BaseHTTP/0.6
    Server Hostname:        127.0.0.1
    Server Port:            8000

    Document Path:          /
    Document Length:        0 bytes

    Concurrency Level:      12
    Time taken for tests:   62.697 seconds
    Complete requests:      120
    Failed requests:        0
    Write errors:           0
    Total transferred:      10920 bytes
    HTML transferred:       0 bytes
    Requests per second:    1.91 [#/sec] (mean)
    Time per request:       6269.746 [ms] (mean)
    Time per request:       522.479 [ms] (mean, across all concurrent requests)
    Transfer rate:          0.17 [Kbytes/sec] received

    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:        0   59 396.0      0    3006
    Processing:   281 3890 9879.3   1971   61132
    Waiting:      281 3890 9879.3   1970   61131
    Total:        282 3949 10215.0   1971   62697

</pre>

<h4>
Servidor AS&iacute;ncrono
</h4>

<pre>
    $ ab -c 12 -n 120 127.0.0.1:8001/

    Server Software:        TornadoServer/3.1.1
    Server Hostname:        127.0.0.1
    Server Port:            8001

    Document Path:          /
    Document Length:        0 bytes

    Concurrency Level:      12
    Time taken for tests:   33.895 seconds
    Complete requests:      120
    Failed requests:        0
    Write errors:           0
    Total transferred:      23280 bytes
    HTML transferred:       0 bytes
    Requests per second:    3.54 [#/sec] (mean)
    Time per request:       3389.531 [ms] (mean)
    Time per request:       282.461 [ms] (mean, across all concurrent requests)
    Transfer rate:          0.67 [Kbytes/sec] received

    Connection Times (ms)
                  min  mean[+/-sd] median   max
    Connect:        0    0   0.1      0       0
    Processing:  3185 3371  58.6   3389    3392
    Waiting:     3185 3371  58.6   3389    3392
    Total:       3185 3371  58.6   3389    3392

    Percentage of the requests served within a certain time (ms)
      50%   3389
      66%   3390
      75%   3390
      80%   3390
      90%   3391
      95%   3391
      98%   3391
      99%   3391


</pre>

<h4>
Resultados
</h4>


+-------------------+---------------+--------------+
| Item              | Synchronous   | ASynchronous |
+-------------------+---------------+--------------+
| Concurrency Level | 12            | 12           |
+-------------------+---------------+--------------+
| Complete requests | 120           | 120          |
+-------------------+---------------+--------------+
| Time taken for    | 62.697 second | 33.89 second |
| tests             |               |              |
+-------------------+---------------+--------------+
| Requests per      | 1.91          | 3.54         |
| second            |               |              |
+-------------------+---------------+--------------+





<h3>Recursos</h3>

<ul>
<li> Tornado website: <a href="http://www.tornadoweb.org"> http://www.tornadoweb.org </a> </li>

<li> Being truly asynchronous with Tornado: <a href="http://papercruncher.com/2013/01/15/truly-async-with-tornado/"> http://papercruncher.com/2013/01/15/truly-async-with-tornado/ </a> </li>
</ul>
